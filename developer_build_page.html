<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSCF: Build System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PSCF<span id="projectnumber">&#160;v1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">PSCF - Polymer Self-Consistent Field Theory</a></li><li class="navelem"><a class="el" href="developer_page.html">Developer Information</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Build System</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="developer_list_page.html">Source File Lists</a> (Prev) <a class="el" href="developer_standards_page.html">Coding Standards</a> (Next) <br  />
</p>
<p>The build system for PSCF relies on the unix "make" utility, and is controlled by a system of makefiles. Understanding of the build system thus requires some familiarity with make and the syntax of makefiles. The discussion of make and makefiles in given below is intended to serve as an initial introduction for developers and users who have little or no experience with make, while also providing some information about conventions used in makefiles within PSCF. Much more complete documentation of the make command is provided by the <a href="https://www.gnu.org/software/make/manual/make.html">online manual</a> for the GNU make command.</p>
<h1><a class="anchor" id="developer_build_make_sec"></a>
Make and makefiles</h1>
<p>The "make" command is a standard unix utility that is used to control compilation and installation of large programs and software packages. The command is invoked from a unix command line by typing "make", optionally followed by one or more command line arguments.</p>
<p>Whenever make is invoked, it searches for an associated "makefile" that specifies the actions that can be performed by make. This makefile must be a file named "makefile" or "Makefile" in the current working directory (i.e,. in the directory from which the make command was invoked).</p>
<h2><a class="anchor" id="developer_build_makefiles_rules_sub"></a>
Makefile rules</h2>
<p>A makefile generally contains a set of "rules". Each rule provide instructions for how to perfom a specific action or type of action, and may contain information about the dependencies among different files. The general syntax for a makefile rule is: </p><div class="fragment"><div class="line">target:  prerequisites</div>
<div class="line">   recipe</div>
</div><!-- fragment --><p> The "target" is a character string that may be either the name of a file that would be created by the associated action or a label that simply describes the purpose of the recipte. The "recipe" associated with a rule is a sequence of unix shell commands that required to perform an action. The "prerequisites" entry is a list of the names of files that are required as inputs to the rule. The list of prerequisites must appear on the same line as the target, separated from the target by a colon. The recipe must start on the line after the line containing the target, and may span one or more lines. In a peculiar quirk of makefile syntax, every line of a makefile recipe must start with an invisible tab character.</p>
<p>The simplest type of makefile rule is one in which the target is the name of an object file that is created by compiling a source file. In this case, the list of prerequisites normally contains the name of the associated *.cpp C++ source file and names of all of the *.h header files that the source file directly or indirectly includes. In simple cases, the recipe for such a rule could be a command that calls the compiler to compile the source file and create the target object file.</p>
<p>As example, suppose A is the name of a class that is defined in a header file A.h for which member functions that are defined in a source file A.cpp in the current working directory. A simple makefile rule for using the gcc compiler to create an associated object file named A.o might look like this: </p><div class="fragment"><div class="line">A.o:  A.cpp A.h</div>
<div class="line">   gcc -o A.o A.cpp</div>
</div><!-- fragment --><p> The list of prerequisites for such a rule should include names of all header files that are directly or indirectly included into the source code file that is compiled. For example, if either A.h or A.cpp contained statements to include the header file "B.h" that contains the definition of another class named B, then B.h would also need to be included in the list of prerequisites for the target A.o.</p>
<p>The make utility uses prerequisite lists to make decisions about what existing files need to be rebuilt if related files are modified. The process for doing this is based on examination of file time stamps. Time stamps are metadata associated with files that indicate the most recent time that a file was modified, and when the file was first created. An existing file that is the target of a makefile rule is out-of-date, and thus needs to be rebuilt, if any file listed as a prerequisite of that target is either: (a) a file that has been modified since the last time that the target file was created or modified, or (b) the target of another makefile rule that can be shown to be out-of-date by examination of the prerequisites of that rule. A file that does not exist is also always out-of-date.</p>
<p>When a makefile rule is invoked, the make command will always first identify any out-of-date prerequisites of that rule that are targets of other makefile rules, then recursively apply any rules required to update all out-of-date prerequisites, and only then perform any actions specified by the recipe for the original rule. This behavior can cause invocation of a rule that builds one file to cause to a cascade of actions that build other related files.</p>
<p>As an example of this behavior, consider the case of a rule that builds an executable file. The rule for constructing an executable file often has a recipe that links an object file to one or more library files, and a list of prerequisites that includes the object file and the required libraries. Each library file may itself be the target of a rule that lists the object files that the library contains as prerequisites. Each of those object files is the target of a rule that compiles a corresponding source file. Invocation of a rule to build an executable file can thus cause the make utility to first compile a set of related source files to create or update any outdated object files, then use an archiver to create or update any outdated library files, and finally use a linker to create the requested executable file.</p>
<p>Makefile rules can contain the following three different types of target:</p>
<ul>
<li><b>File name targets</b>, for which the target is the name of a specific file that needs to be created by the build system, such as an object, library or executable file.</li>
<li><b>File patterns targets</b>, for which the target is given by a filename pattern that, for example, might match any filename with a specific file name extension.</li>
<li><b>Phony targets</b>, for which in which the target is a label such as "clean" or "all" but that is neither a file name or a file name pattern, but merely serves as a label for the rule.</li>
</ul>
<p>Rules with targets that are file name patterns or phony targets are referred to here pattern rules.</p>
<h2><a class="anchor" id="developer_build_makefiles_pattern_sub"></a>
Pattern rules</h2>
<p>A pattern rule is typically used to specify a general procedure for creating any target file with a specific file extension by applying a specific recipe to any corresponding files with the same base name but a different file name extension. The target of a pattern rule must contain exactly one instance of the wildcard symbol %, which may be matched by any continuous string of charcters. The % symbol may also used in one or more of the pre-requisites of a pattern rule to represent the same string as the one that matches % in the pattern for the target. For example, a rule with a target and prerequisite of the form </p><div class="fragment"><div class="line">%.o: %.cpp</div>
<div class="line">   recipe...</div>
</div><!-- fragment --><p> specifies how make any object file with of the form name.o from a source and header file with the same base name, with names of the form name.cpp and name.h.</p>
<p>Other automatically defined variables may be used in the recipe associated with a pattern rule to refer to the target and various prerequisites. Specifically, the symbol $@ refers to the target, $&lt; refers to the first pre-requisite, and $^ refers to a list of all pre-requisites separated by spaces.</p>
<p>Rules for building individual files can be combined with pattern rules to concisely define build instructions. PSCF makefiles generally include a specific rule for each relevant *.o object file target in which the rule lists all of the prerequisites of that target file but does not explicitly specify a recipe. In this case, no recipe is required because make can infer the required recipe from a related pattern rule for which target file name matches the target pattern.</p>
<p>More detailed documentation of pattern rules is available <a href="https://www.gnu.org/software/make/manual/html_node/Pattern-Rules.html">here </a>.</p>
<h2><a class="anchor" id="developer_build_makefiles_phony_sub"></a>
Phony targets</h2>
<p>A makefile rule target that is not a file name or a file name pattern is referred to as a "phony" target. Rules with phony targets are used to label an action that is not designed to build a specific target file. Invoking make with an argument that is the name of a phony target always causes the make to rebuild any outdated pre-requisites of that target and then apply any associated recipe.</p>
<p>PSCF makefiles generally contain several standard phony targets. Every makefile contains named "all" and "clean". Upper level and namespace level directories generally have a targets named "veryclean". The purposes of these standard targets are:</p>
<ul>
<li>"all" builds all of the target files for which rules are defined in the makefile</li>
<li>"clean" removes any files that were generated by making the "all" target.</li>
<li>"veryclean" removes files that were generated either by calling the configure script or by running making "all".</li>
</ul>
<p>The "all" target generally specifies a list of prerequisites but but no recipe. Invocation of the "all" rule thus causes make to rebuild any out-of-date prerequisites of the rule. The list of pre-requisites of the "all" target normally includes all of the file targets that the makefile is responsible for constructing.</p>
<p>The "clean" and "veryclean" targets instead generally include recipes but no pre-requisites. Invoking either of these rules simply causes make to apply the recipe, which removes files created previously by the build system.</p>
<p>Makefiles can specify that particular targets are phony (i.e., do not correspond to file names) by listing them as prerequisites of a standard built-in target named .PHONY. Thus for example, a makefile with three phony targets named "all", "clean" and "veryclean" could include a rule of the form </p><div class="fragment"><div class="line">.PHONY: all clean veryclean</div>
</div><!-- fragment --><p> as a way of declaring that these three names are phony targets. The effect of the .PHONY target is to guarantee that the names of each pre-requisites will be treated as a phony targets even even if files with the names were found to exist.</p>
<h2><a class="anchor" id="developer_build_makefiles_var_sub"></a>
Makefile variables</h2>
<p>Makefiles may define and use variables. Each makefile variable is a symbolic name for a character string, which is known as the value of the variable. By convention, almost all variable names used in PSCF are strings of upper case letters and underscores, such SRC_DIR.</p>
<p>An expression for assigning a value to a makefile variable contains the name of the variable on the left of an equals sign and the value to the right. For example, </p><div class="fragment"><div class="line">ROOT_DIR = /users/smith/<a class="code hl_namespace" href="namespacepscfpp.html">pscfpp</a></div>
<div class="ttc" id="anamespacepscfpp_html"><div class="ttname"><a href="namespacepscfpp.html">pscfpp</a></div><div class="ttdoc">Python package of all python modules provided with PSCF.</div><div class="ttdef"><b>Definition</b> <a href="____init_____8py_source.html#l00001">__init__.py:1</a></div></div>
</div><!-- fragment --><p> assigns an absolute path string as the value of variable ROOT_DIR.</p>
<p>A reference to the value of a variable is represented by a symbol in which the variable name in enclose in parentheses and a $ sign is placed before the opening parenthesis. For example, the symbol  represents the value of the variable ROOT_DIR. <br  />
 References to makefile variable values may be used on the right hand side of assignments and in other makefile expressions. For example, the makefile variable SRC_DIR is assigned a value by the expression </p><div class="fragment"><div class="line">SRC_DIR = $(ROOT_DIR)/src</div>
</div><!-- fragment --><p> in which $ is expanded into the actual value of ROOT_DIR (i.e., the path to the PSCF root directory) and then concatenated with the string "/src" to obtain a string that is the path to the PSCF src directory.</p>
<h2><a class="anchor" id="developer_build_make_include_sub"></a>
Makefile include directive</h2>
<p>Makefiles can use the "include" directive to include other make files or makefile fragments. For example, the directive </p><div class="fragment"><div class="line">include $(SRC_DIR)/pscf/sources.mk</div>
</div><!-- fragment --><p> would cause the sources.mk file in the PSCF src/pscf directory to be copied verbatim into the current makefile.</p>
<h2><a class="anchor" id="developer_build_makefiles_command_sub"></a>
Calling the make command</h2>
<p>When make is invoked with a single argument that is the target of a makefile rule, and that target is either the name of a file or a phony target, then the make command will execute the action associated with that rule. For example, </p><div class="fragment"><div class="line">make clean</div>
</div><!-- fragment --><p> will cause make to apply the recipe associated with the "clean" target in the associated makefile.</p>
<p>If make is invoked without any argument, by typing </p><div class="fragment"><div class="line">make</div>
</div><!-- fragment --><p> on a line by itself, then, by default, the make command invokes the first rule in the associated makefile, which is known as the default rule. The default rule in every makefile in the PSCF repository has a phony target named "all". In the PSCF build system, the commands "make" and "make all" thus always have the same effect. The effect of either command is generally to create or recreate all of the main targets of the makefile and all of their pre-requisites.</p>
<p>When "make" or "make all" is invoked from the root, bld or src directory, make will build the entire PSCF package. When "make" or "make all" is invoked from a namespace level subdirectory of src or bld, make will compile almost all of the source files in that namespace level subdirectory tree and creates an associated library containing all of the resulting object files. (The only source files that are not compiled in this case are source files associated with unit tests in the tests subdirectory of a namespace level directory). When "make" or "make all" is invoked in the r1d, rpc, or rpg namespace level subdirectory of either the src or bld directory, make will also create an associated executable file named pscf_1d, pscf_pc, or pscf_pg, respectively, and install that file in the PSCF bin directory.</p>
<h1><a class="anchor" id="make_dependency"></a>
Dependency files (*.d files)</h1>
<p>The pattern rules used by PSCF to compile a source file with file extension .cpp or .cu create both an object file with file extension .o and a dependency file with file extension *.d whenever a source file is compiled. The resulting dependency file defines a makefile rule that lists all of the prerequisites of the corresponding object file, but that has no associated recipe. The dependency file associated with an object file named Class.o defines a makefile rule that, is simplified form, might something like this: </p><div class="fragment"><div class="line">Class.o: Class.cpp Class.h Header1.h Header2.h ....</div>
</div><!-- fragment --><p> The rule defined in a dependency file does not contain a recipe because the make utility can infer the required recipe from related pattern rules that specifies how to create any *.o object file from either *.cpp or *.cu source file with the same base name. The list of prerequisites for each object (*.o) file target includes the corresponding source file (with extension .cpp or .cu) and all of the header files (extension .h) that this source file directly or indirectly includes via C/C++ preprocessor #include directives. This list of prerequisites is generated automatically by using a compiler option to analyze these include directives. The list of prerequisites generated by the PSCF build system also generally includes one or more config.mk configuration files that define makefile variables whose values can affect conditional compilation of some features. Though not shown in the above example, the paths to the target and its prerequisites given in the rule defined in a dependency file are all given as absolute paths, defined relative to the root of the entire filesystem.</p>
<p>Makefiles that are located in subdirectories of the PSCF src or bld directories all contain expressions that include multiple dependency files via include directives of the form </p><div class="fragment"><div class="line">-include $([directory]_OBJS:.o=.d)</div>
</div><!-- fragment --><p> In this type of expression, [directory] represents the mangled name of a directory, and [directory])_OBJS is the name of a makefile variable that lists all of the object file targets in that directory. The expression ([directory]_OBJS:.o=.d) uses a makefile text manipulation operator to replace the .o file extension in each file in this list by .d extension, thus creating a corresponding list of dependency files. The effect of this include directive is thus to instruct make to attempt to include the *.d dependency files associated with each of the object files listed in variable [directory]_OBJS. <br  />
 The dash in front of the "include" keyword instructs make to continue quietly if any particular dependency file does not yet exist.</p>
<p>Because dependency files are created as a side effect of compilation, the dependency file associated with a source file does not exist before the first time that source file compiled. In this case, however, because the associated object file does not yet exist, the object file target is always out-of-date, since non-existent files are always out of date, and so will always be built if the object file target is is needed as a prerequisite of another target (e.g,, as a prerequisite of a library or executable file). The list of prerequisistes of an object file is thus actually not needed or relevant until the object file exists - the list of prerequisites of a makefile rule is only used to determine if an <em>existing</em> target file is out-of-date and thus needs to be recreated.</p>
<h1><a class="anchor" id="developer_build_config_sec"></a>
Build configuration files (config.mk files)</h1>
<p>The PSCF src, bld and src/util directories each contain a file named config.mk that we refer to as a build configuration file. These are files that define and assign values to a variety of makefile variables that are needed throughout the build system, and that are included verbatim by other makefiles. Default versions of these three build configuration files are installed by the configure script. Configuration may be modified by the user, either by manually editing them or (more often) by using the setopt script to enable, disable or modify definitions of specific variables from the command line.</p>
<p>The config.mk files in the srd and bld directories are nearly identical files that contain code to assign values to the same set of variables, with equal default values for almost all variables. The only variable that is treated differently in these files by default is the variable BLD_DIR, which is assigned different values in src/config.mk and bld/config.mk in order to enable users to perform either out-of-source or in-source builds, as discussed elsewhere).</p>
<p>Most of the variables defined in the src/config.mk and bld/config.mk files fall into one of the following three categories:</p>
<ul>
<li><b>Directory path variables:</b> The variables ROOT_DIR, SRC_DIR, BLD_DIR, and BIN_DIR specify absolute paths to the PSCF root directory and several of its subdirectories, as discussed in a previous manual page.</li>
<li><b>Variables that enable optional features:</b> The variables UITL_DEBUG and PSCF_CUDA control whether or not particular optional features are enabled when PSCF is compiled, as discussed here.</li>
<li><b>Variables used in pattern rules</b>: A variety of variables such as CXX, CPP_FLAGS, CXX_FLAGS, LD_FLAGS are used in the pattern rules for compilation of individual source files.</li>
</ul>
<p>The meaning and usage of many of the variables defined in the these two very similar files is discussed in extensive comments with these files, as well as in the discussion of pattern rules given below.</p>
<h1><a class="anchor" id="developer_build_upper_sec"></a>
Makefiles in upper-level directories (root, bld/ and src/ directories)</h1>
<p>Complete instructions for users for how to compile and build PSCF are given in a <a class="el" href="install_overview_page.html">another section</a> of this manual. From the point of view of a user, the key step is simply to invoke "make" or (equivalently) "make all" from within any of three possible locations: Invoking make from either the PSCF root directory or the build directory performs an out-of-source build, while invoking make from the src/ directory performs an in-source build.</p>
<p>The recipes for the "all" target of the makefiles in the root, bld/ and src/ directories are all simply wrappers for make commands in lower-level subdirectories.</p>
<p>The rule for the "all" target for the makefile in the PSCF root directory is given by: </p><div class="fragment"><div class="line">all:</div>
<div class="line">   cd bld ; $(MAKE)</div>
</div><!-- fragment --><p> Here,  is a standard variable that represents the name of the make command, so this recipe is equivalent to </p><div class="fragment"><div class="line">cd bld ; make</div>
</div><!-- fragment --><p> This recipe instructs make to change directory to the bld/ directory and then invoke from there. Invoking make in the root directory is thus completely equivalent to invoking it from bld/. Invoking make from either of these locations performs an out-of-source build in which intermediate files are installed in the bld/ directory.</p>
<p>The makefiles in the bld/ and src/ directories each include the "config.mk" file located in the same directory. The "all" target in each of these two makefiles is given by: </p><div class="fragment"><div class="line">all:</div>
<div class="line">   all-cpu</div>
<div class="line">ifdef PSCF_CUDA</div>
<div class="line">   cd rpg; make</div>
<div class="line">endif</div>
</div><!-- fragment --><p> In this rule, "all-cpu" refers to the phony target of a related rule </p><div class="fragment"><div class="line">all-cpu:</div>
<div class="line">   cd util; $(MAKE)</div>
<div class="line">   cd pscf; $(MAKE)</div>
<div class="line">   cd prdc; $(MAKE)</div>
<div class="line">   cd r1d; $(MAKE)</div>
<div class="line">   cd rpc; $(MAKE)</div>
</div><!-- fragment --><p> The recipe for the all-cpu target, which is invoked by the recipe for all, instructs make to simply cd into 5 of the 6 namespace level directories of src/ or bld/ and invoke make from within each of them. The 5 namespace directories that appear in the reciple for the all-cpu rule contain all of the code required to build the CPU programs pscf_1d and pscf_pc, but not that required to build the GPU program pscf_pg. The remaining line of the recipe for the "all" rule, contains the pair of commands "cd rpg; $(MAKE)$" that cause make to cd into rpg and call make from there in order to compile the code required to build the pscf_pg GPU program. This last line is surrounded by a makefile "ifdef ... if" block, however, that allows it to be executed if and only if compilation of CUDA code has been enabled by defining the variable PSCF_CUDA in the associated config.mk file.</p>
<p>Recipes for the "all" targets in these upper level makefiles thus simply instruct make to descent into to namespace level subdirectories of bld/ or src/ and recursively invoke itself from within these directories. Most of the nontrivial makefile code required to build PSCF thus appears within makefiles in the namespace level directories.</p>
<h1><a class="anchor" id="developer_build_namespace_sec"></a>
Makefiles in namespace-level directories</h1>
<p>As already discussed, the src/ and bld/ directories have analogous internal structures, and either can be used as the "build" directory for, respectively, out-of-source or in-source builds. The src/ and bld/ directories each contain 6 subdirectories named named util/, pscf/, prdc/ r1d/, rpc/, rpg/ that we refer to as namespace level directories, because each contains the source code defined in a particular C++ namespace. Each namespace level subdirectory of src/ and bld/ contains a makefile that controls compilation of source files located in the corresponding subdirectory of src/.</p>
<h2><a class="anchor" id="developer_build_namespace_all_sub"></a>
The "all" target</h2>
<p>The makefile in each namespace level subdirectory of src/ or bld/ contains a rule with a phony target named "all". Invoking "make" or "make all" from a namespace level directory invokes the "all" rule, and causes make to perform the following actions:</p>
<ul>
<li>The "all" rule compiles all of the source files in the corresponding namespace level subdirectory of src/, and places the resulting object and dependency files within the namespace level subdirectory from which make was invoked.</li>
<li>The "all" rule creates a static library files that contains the contents of the resulting object files, and places that file in the root of the namespace level directory from which make was invoked.</li>
<li>When invoked from the r1d/, rpc/ or rpg/ namespace level subdirectory of src/ or bld/, the "all" rule also creates an executable program file named pscf_1d, pscf_pc, or pscf_pg, respectively, and installs that file in the PSCF bin/ directory.</li>
</ul>
<p>Each of these processes is described in a bit more detail below.</p>
<p>The object and dependency files that are created by compiling a source file both have the same base name as the corresponding source file, with different file name extensions. This object and dependency file are both placed either in the same directory as the source file, in the case of an in-source build, or in an analogous directory within the bld/ directory, in the case of an out-of-source build.</p>
<p>The library file that is created by the "all" rule of a namespace level has a name of the form lib[namespace].a, in which [namespace] denotes the name of the relevant namespacel level directory. For example, the library that is created by invoking "make" or "make all" from the bld/prdc/ directory is named bld/prdc/libprdc.a. This library is an archive that contains the contents of object files created by compiling all source files in the src/prdc directory.</p>
<p>The r1d/, rpc/, and rpg/ directories each contain a single source file named <a class="el" href="pscf__1d_8cpp.html">pscf_1d.cpp</a>, <a class="el" href="pscf__pc_8cpp_source.html">pscf_pc.cpp</a>, or <a class="el" href="pscf__pg_8cu_source.html">pscf_pg.cu</a>, respectively, that implements the main function for one of the executable programs created by PSCF. We refer to these as program source files. Invoking "make" or "make all" from within the r1d/, rpc/, or rpg/ namespace level directory of either bld/ or src/ will cause this file to be compiled and linked to library files in order to create a corresponding executable file that, by default, is installed in the PSCF bin/ directory. For example, invoking "make all" from either src/rpc or bld/rpc causes the creation of the executable file bin/pscf_pc.</p>
<h2><a class="anchor" id="developer_build_namespace_mkfiles_sub"></a>
Makefile fragments</h2>
<p>In addition to a makefile, each namespace level subdirectory of the src/ directory contains 3 makefile fragments that are included by other makefiles. The names and contents of these three makefile fragments are summarized below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Filename   </th><th class="markdownTableHeadNone">Contents    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sources.mk   </td><td class="markdownTableBodyNone">Lists of object file targets, rule for library    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">patterns.mk   </td><td class="markdownTableBodyNone">Pattern rules for source file compilation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">includes.mk   </td><td class="markdownTableBodyNone">List of files to be included by makefiles   </td></tr>
</table>
<p>Each of these types of file is described in more detail below.</p>
<p><b>Source list files (sources.mk)</b></p>
<p>As discussed in a previous <a class="el" href="developer_list_page.html">manual page</a>, the sources.mk file in each namespace level directory defines a makefile variable whose value is a list of the object files that should be created by compiling source files in that directory. The name of this variable is a string of the form [namespace]_OBJS, in which [namespace] represents the name of the relevant namespace level directory. For example, the file src/prdc/sources.mk file defines a variable of this kind that is named prdc_OBJS. Every file listed in the value of this variable is given as an absolute path to a file in the relevant build directory with a name that ends with file extension .o.</p>
<p>Each sources.mk file also defines variable whose value is the path to the associated library, and a makefile rule for constructing that library. The variable contains the path to the library has a name of the form [namespace]_LIB, where [namespace] represents the name of the namespace level directory. As an example, the relevant part of the file src/prdc/sources.mk file is shown below: </p><div class="fragment"><div class="line">prdc_LIBNAME=prdc</div>
<div class="line">prdc_LIB=$(BLD_DIR)/prdc/$(prdc_LIBNAME).a</div>
<div class="line"> </div>
<div class="line">prdc_LIB: $(rpg_OBJS)</div>
<div class="line">   $(AR) $(prdc_LIB) $(prdc_OBJS)</div>
</div><!-- fragment --><p> The first two lines of this makefile snippet assign prdc_LIB a value that is the absolute path to a file named libprdc.a in the prdc/ subdirectory of the relevant build directory (i.e., bld/ or src/). The absolute path to the build directory is given in the definition of prdc_LIB by the value of the makefile variable BLD_DIR.</p>
<p><b>Pattern rule files (patterns.mk):</b></p>
<p>The patterns.mk file in each namespace level directory defines the pattern rules that are used to compile *.cpp C++ files and *.cu CUDA C++ files in that namespace level directory. These pattern rules are discussed in more detail below.</p>
<p><b>Include list files (includes.mk):</b></p>
<p>The includes.mk file in each namespace level directory is a short makefile fragment that contains "include" statements that include makefile fragments that are required by all makefiles in the same directory and its subdirectories.</p>
<p>As example, the src/prdc/include.mk file contains the following include statements: </p><div class="fragment"><div class="line">include $(BLD_DIR)/util/config.mk</div>
<div class="line"> </div>
<div class="line">include $(SRC_DIR)/util/sources.mk</div>
<div class="line">include $(SRC_DIR)/pscf/sources.mk</div>
<div class="line">include $(SRC_DIR)/prdc/sources.mk</div>
<div class="line"> </div>
<div class="line">include $(SRC_DIR)/prdc/patterns.mk</div>
</div><!-- fragment --><p> Comments:</p>
<ul>
<li>This file includes not only the patterns.mk and sources.mk file from the same prdc/ namespace level subdirectory of src/, but also sources.mk files from two other namespace level directories (util/ and pscf/) that contain code that are used within the prdc/ directory.</li>
<li>This file also includes the config.mk build configuration file from the util/ subdirectory of the build directory, because this build configuration file contains a some makefile variable definitions that are needed elsewhere.</li>
<li>This include.mk file does not include the main build configuration file located at /config.mk, for reasons that are explained below.</li>
</ul>
<h2><a class="anchor" id="developer_build_namespace_makefile_1_sub"></a>
Example: namespace level makefile, with no program file</h2>
<p>We are now in a position to explain the essential components of a makefile in a namespace-level subdirectory of bld/ or src/. We first consider the structure of a makefile in a namspace level directory such as pscf/ or prdc/ that does not contain a program file. As an example, the following code snippet shows the essential elements of the file bld/prdc/makefile that are necessary to execute the "all" rule defined in this file:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># -------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor"># Include makefile fragments</span></div>
<div class="line"> </div>
<div class="line">BLD_DIR_REL =..</div>
<div class="line">include $(BLD_DIR_REL)/config.mk</div>
<div class="line">include $(SRC_DIR)/prdc/include.mk</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># -------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor"># Main targets</span></div>
<div class="line"> </div>
<div class="line">all: $(prdc_OBJS) $(prdc_LIB)</div>
<div class="line"> </div>
<div class="line">   .</div>
<div class="line">   .</div>
<div class="line">   .</div>
<div class="line"> </div>
<div class="line"># -------------------------------------------------------------</div>
<div class="line"><span class="preprocessor"># Include dependency files</span></div>
<div class="line"> </div>
<div class="line">-include $(prdc_OBJS:.o=.d)</div>
<div class="line">-include $(pscf_OBJS:.o=.d)</div>
<div class="line">-include $(util_OBJS:.o=.d)</div>
</div><!-- fragment --><p>In this example, the three vertical dots below the makefile rule with the target "all" are used to indicate a section of the file that has been omitted for clarity. The omitted section of this file contains rules with targets named "clean" and "veryclean" that we do not need to consider in order to understand the implementation of the "all" rule.</p>
<p>This makefile has three sections that are marked by comments and horizontal separators.</p>
<p>The first section contains directives that includes several related makefile fragments, as indicated by the associated comment. In the first line of this section, the variable BLD_DIR_REL is assigned a value ".." that gives the relative path from the directory bld/prdc that contains this file to the build directory bld/, which is the parent directory. The string ".." is standard notation for the path to a parent directory in a unix filesystem. The following line then includes the build configuration file bld/config.mk in this parent directory. The last line of this section includes the file src/prdc/include.mk fle, which thus indirectly includes the required patterns.mk file and several other makefile fragments, as discussed above.</p>
<p>Note that the directive that includes the configuration file bld/config.mk uses a relative path to refer to the bld/ directory, rather than referencing the variable BLD_DIR to indicate this directory as done in most other places in the build system. This is necesssary because the variable BLD_DIR is defined in this config.mk configuration file, and so cannot be used until after this file has been included.</p>
<p>The second section of this makefile file lists several main makefile rules. All of these have been omitted here except for the rule with the target "all", which is the focus of this discussion. The list of prerequisites for the "all" rule contains all of the files in the list  of object files in the relevant namespace-level directory, plus the associated library file . (Recall that prdc_OBJS and prdc_LIB are both defined in the file src/prdc/sources.mk that is indirectly included via the include.mk file). Invocation of the "all" rule thus causes any of the files in this list that are non-existent or out-of-date to be created or re-created.</p>
<p>The last section of this makefile uses the "include" directive to automatically include several long lists of dependency files into this makefile. Each of the included *.d dependency file contains a makefile rule that lists the prerequisites for a corresponding object file, and thus provides the information necessary for make to decide when a particular object file that already exists needs to be rebuilt because one or more of its prerequisites has been modified or become out-of-date.</p>
<h2><a class="anchor" id="developer_build_namespace_makefile_2_sub"></a>
Example: namespace level makefile, with a program file</h2>
<p>Makefiles for the r1d/, rpc/, rpg/ namespace-level directories are slightly more complicated than the example given above because they each contain an additional rule to create an executable file.</p>
<p>As an example, we consider the makefile in directory src/rpc, which contains source code for pscf_pc program. This directory contains a file <a class="el" href="pscf__pc_8cpp_source.html">src/rpc/pscf_pc.cpp</a> that defines the main function for the pscf_pc executable, which we refer to as the program source file. The object file that is created by compiling the program source file is listed as a pre-requisite of the corresponding executable file, which is created by the "all" rule because the executable file is listed as a pre-requisite of the "all" target. <br  />
</p>
<p>The essential elements of the makefile in the src/rpc directory are shown below, with a few sections omitted for clarity:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#------------------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor"># Include makefile fragments</span></div>
<div class="line"> </div>
<div class="line">BLD_DIR_REL =..</div>
<div class="line">include $(BLD_DIR_REL)/config.mk</div>
<div class="line">include $(SRC_DIR)/rpc/include.mk</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#-----------------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor"># Paths to pscf_pc program files</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Base path to *.o and *.d files for pscf_pc</span></div>
<div class="line">PSCF_PC=$(BLD_DIR)/rpc/pscf_pc</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Path to pscf_pc executable file</span></div>
<div class="line">PSCF_PC_EXE=$(BIN_DIR)/pscf_pc</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#-----------------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor"># Main targets </span></div>
<div class="line"> </div>
<div class="line">all: $(rpc_OBJS) $(rpc_LIB) $(PSCF_PC_EXE)</div>
<div class="line"> </div>
<div class="line">  .</div>
<div class="line">  .</div>
<div class="line">  .</div>
<div class="line"> </div>
<div class="line"># Rule <span class="keywordflow">for</span> pscf_pc executable file</div>
<div class="line">$(PSCF_PC_EXE): $(PSCF_PC).o $(PSCF_LIBS)</div>
<div class="line">   $(CXX) $(LDFLAGS) -o $(PSCF_PC_EXE) $(PSCF_PC).o $(LIBS)</div>
<div class="line"> </div>
<div class="line">  .</div>
<div class="line">  .</div>
<div class="line">  .</div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">#-----------------------------------------------------------------------</div>
<div class="line"># Include dependency files</div>
<div class="line"> </div>
<div class="line">-include $(rpc_OBJS:.o=.d)</div>
<div class="line">-include $(prdc_OBJS:.o=.d)</div>
<div class="line">-include $(pscf_OBJS:.o=.d)</div>
<div class="line">-include $(util_OBJS:.o=.d)</div>
<div class="line">-include $(PSCF_PC).d </div>
</div><!-- fragment --><p> As in the first example, we use vertical dots to indicate sections of the file that have been ommitted for clarity.</p>
<p>The following new elements are present this makefile, but do not exist in a namespace-level makefile for a directory that does not contain a program source file:</p>
<ul>
<li>Definition of a variable PSCF_PC gives the shared part of the paths for the object and dependency file that will be created by compiling the program source file src/pscf_pc.cpp, without the .o and .d file name extensions.</li>
<li>Definition of a variable PSCF_PC_EXE gives the path to the resulting executable file, /pscf_pc.</li>
<li>The executable file  is listed as an additional pre-requisite of the "all" target.</li>
<li>This makefile contains an additional rule to construct the executable by linking the object file .o to a list of libraries given by the value of the variable </li>
<li>The dependency file .d that is created by compiling the program source file is included in the last line of the makefile</li>
</ul>
<p>Invoking the "all" rule for this makefile builds all of the object files in the list , builds the resulting library , and also constructs the executable .</p>
<p>In a namespace-level directory that contains a program source file, the object file that is created by compiling the program source file is added to the object file list for that directory, and so is not added to the associated static library. This object file is instead created by the "all" rule because it is listed as a pre-requisite of the executable, and thus must be created in order to create the executable.</p>
<h1><a class="anchor" id="make_patterns"></a>
Pattern rules (patterns.mk files)</h1>
<p>Each namespace level subdirectory of the src/ directory has a makefile fragment named "patterns.mk". This file defines pattern rules for compiling *.cpp and *.cu source files in that directory or namespace. These pattern rules have the same structure in all six namespace level directories.</p>
<p>The patterns.mk file in each namespace level source directory contains a pattern rule for compiling C++ source files with extension .cpp that always looks like this: </p><div class="fragment"><div class="line">$(BLD_DIR)/%.o:$(SRC_DIR)/%.cpp</div>
<div class="line">        $(CXX) $(CPPFLAGS) $(CXXFLAGS) $(INCLUDES) $(DEFINES) -c -o $@ $&lt;</div>
<div class="line">ifdef MAKEDEP</div>
<div class="line">        $(MAKEDEP) $(INCLUDES) $(DEFINES) $(MAKE_DEPS) -S$(SRC_DIR) -B$(BLD_DIR) $&lt;</div>
<div class="line">endif</div>
</div><!-- fragment --><p> In directories that contain CUDA C++ source files, indicated by an extension *.cu, the patterns.mk file also contains an analogous pattern rule for compiling these files, which uses the NVidia CUDA compiler rather than a C++ compiler. Both of the patterns creates rules for creating an object file with file extension *.o in a subdirectory of the build directory $(BLD_DIR) by compiling a *.cpp or *.cu source file with the same base name in the corresponding subdirectory of the source directory $(SRC_DIR).</p>
<p>In these pattern rules, the symbol % is a wildcard that represents a string that appears in the path for the target file that may also appear in one or more pre-requisites. The rule shown above thus describes how to create a target object file in the build directory with a path of the form $(BLD_DIR)%.o by compiling a corresponding source file in the source directory with a path of the form $(SRC_DIR)/%.cpp, in which % represents the common part of the two paths. The common part of these paths may include one or more directory separator symbols and the name or names of subdirectories of the src directory, as well as the base file name. In order for this pattern rule to work correctly for out-of-source builds, the PSCF bld directory must have the same internal directory structure as the src directory.</p>
<p>The recipe for this rule contains two lines with different purposes. The first line of the recipe actually calls the compiler command, represented by value of the variable $(CXX), to compile the source file and create the object file. The second line is contained within a makefile ifdef construct that executes the second line if and only if the makefile variable MAKEDEP is defined (which it normally is). This second line calls a script whose name is given by the variable $(MAKEDEP) to create a corresponding dependency file with extension .d as a side-effect of compilation.</p>
<p>The following makefile variables are used in the first line of the recipe to define a rule for compiling a source file:</p>
<ul>
<li>BLD_DIR: Absolute path to the build directory</li>
<li>SRC_DIR: Absolute path to the pscfpp/src directory</li>
<li>CXX: name of the C++ compiler executable</li>
<li>CPPFLAGS: flags for the C preprocessor</li>
<li>CXXFLAGS: general flags for the C++ compiler (optimization, warnings, etc.)</li>
<li>INCLUDES: directories to search for C++ header files, using the -I option</li>
<li>DEFINES: String of any C++ preprocessor macro definitions</li>
</ul>
<p>Values for the variables BLD_DIR, SRC_DIR, CXX, CPPFLAGS, CXXFLAGS and INCLUDES are all defined in the main config.mk configuration located in the root of the build directory.</p>
<p>The DEFINES variable, if not empty, contains a series of preprocessor macro definitions that are defined using the "-D" compiler option, which can be used to control use of the C/C++ preprocessor to control conditional compilation of some features. Thus, for example, if both debugging and CUDA compilation are enabled, the value $(DEFINES) within the file src/pscf/patterns.mk might expand to </p><div class="fragment"><div class="line">$(DEFINES) =&gt; -DUTIL_DEBUG -DPSCF_CUDA</div>
</div><!-- fragment --><p> The DEFINES variable is assigned a value in the patterns.mk files of each namespace level subdirectory of src/, and is assigned slightly different values in different directories.</p>
<p>The variables MAKEDEP and MAKE_DEPS are used only in the second line of this recipe, in order to construct a *.d dependency file.</p>
<p>The value of MAKEDEP is the name of a script that is used to generate dependency files. The value of this variable is assigned in the main config.mk configuration file in the build directory, and assigned a value bin/makeDep by default.</p>
<p>The value of MAKE_DEPS is a list of build configuration files that the script that creates dependency files should list as additional pre-requisites for all object files in the relevant namespace. Each additional dependency in this list is preceded by the symbol "-A" which the MAKEDEP script recognizes as a label for an additional dependency. The value of this variable usually expands to a string </p><div class="fragment"><div class="line">MAKE_DEPS = -A$(BLD_DIR)/config.mk -A$(BLD_DIR)/util/config.mk</div>
</div><!-- fragment --><p> that lists the config.mk configuration files in the build directory and in the util subdirectory of the build directory as additional pre-requisites. These files are listed as extra pre-requisites in the makefile rule for building an object file because they each contain definitions of makefile variables that, if modified, can change the list of preprocessor macros that are passed to the compiler via the DEFINES variable, and thereby change the assembly code that is produced by compilation.</p>
<p>The definitions of DEFINES and MAKE_DEPS within the file src/rpc/patterns.mk are shown below as an example: </p><div class="fragment"><div class="line"><span class="preprocessor"># C preprocessor macro definitions</span></div>
<div class="line">DEFINES=$(UTIL_DEFS) $(PSCF_DEFS) $(PRDC_DEFS) $(RPC_DEFS)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Dependencies of source files in src/rpc on makefile fragments</span></div>
<div class="line">MAKE_DEPS= -A$(BLD_DIR)/config.mk</div>
<div class="line">MAKE_DEPS+= -A$(BLD_DIR)/util/config.mk</div>
</div><!-- fragment --><p> The DEFINES variable is constructing by concatenating the variables (UTIL_DEFS, PSCF_DEFS, etc.) for this namespace (i.e., RPC_DEFS) and for all namespaces upon which this namespace depends (i.e., UTIL_DEFS, PSCF_DEFS, and PRDC_DEFS). The resulting string contains all of the preprocessor definitions that are allowed to be used by code in this namespace.</p>
<p>The MAKE_DEPS variable contains a list of build configuration files whose contents can effect compilation of source code in this namespace. This list always contains the main config.mk file from the parent build directory, the config.mk file for the namespace level directory of interest, and config.mk files for any namespace level directories upon which this directory depends. For the src/rpc directory, the MAKE_DEPS thus contains paths to the config.mk files in the pscf/, prdc/ and util/ subdirectories, as well as the main config file /config.mk. These build configuration files are added to the list of dependencies for every object file in this namespace because changes to these config.mk files can change which preprocessor macros are defined or which compiler options are set, and thus can change the contents of the resulting object files.</p>
<h1><a class="anchor" id="developer_build_make_subdirectory_sec"></a>
Makefiles in lower-level src subdirectories</h1>
<p>As a convenience for developers, every subdirectory of the namespace level directories also contains a makefile. The "all" target of each such src/ subdirectory makefile executes an in-source build of the files in the subdirectory that contains makefile and any of its subdirectories. The structure of the makefiles in subdirectories of the namespace level directories is very similar to that of the namespace level makefiles, except that the all targets does not build a library or executable.</p>
<p>During development, if you are working from the command line using a text editor, one convenient way to test whether a source file that you have just modified compiles correctly is usually to just enter </p><div class="fragment"><div class="line">&gt; make all</div>
</div><!-- fragment --><p> from the directory that contains the new or newly modified source file. If automatic dependency generation is enabled, and if you only modify one class at a time, this will normally cause the build system to compile only the source file that you have just modified. If a directory contains more than one incomplete or broken file, you should usually comment out out all but one of these broken files (the one you are working on) in the definition of the [directory]_ variable in the corresponding sources.mk file, and then uncomment each such file when you are ready to work on it.</p>
<h1><a class="anchor" id="developer_build_make_abspath"></a>
Use of absolute paths for object file targets</h1>
<p>The file name conventions used in the PSCF makefile system make it awkward for a user to explictly request compilation of a specific source file by using the name of that file as an argument of the make command. The awkwards arises from the fact that the build system uses absolute paths for all object files targets, and the fact that the "make" program is not smart enough to recognize when an absolute and relative path are equivalent. As a result, the only way explicitly request compilation of a single source file is to use the absolute path to the object file as the argument of the make command. For example, if the absolute path to the root PSCF directory within a user account named "smith" was "/users/smith/pscfpp/", user "smith" could compile the source file src/rpc/simulate/Simulator.cpp by entering </p><div class="fragment"><div class="line">make /users/george/<a class="code hl_namespace" href="namespacepscfpp.html">pscfpp</a>/src/rpc/simulate/Simulator.o</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">make ~/<a class="code hl_namespace" href="namespacepscfpp.html">pscfpp</a>/src/rpc/simulate/Simulator.o</div>
</div><!-- fragment --><p> from either the src/rpc/simulate or src/rpc directory. The need to type out such long absolute paths is so inconvenient, however, that we recommend developers instead who want to compile single files in-source instead get in the habit of simply using "make all" from the directory that contains the file of interest, as described above.</p>
<p><br  />
 <a class="el" href="developer_list_page.html">Source File Lists</a> (Prev) <a class="el" href="developer_page.html">Developer Information</a> (Up) &#160; &#160; &#160; &#160; <a class="el" href="developer_standards_page.html">Coding Standards</a> (Next) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 28 2025 00:57:29 for PSCF by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
