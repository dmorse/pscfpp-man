<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSCF: C++ Class Templates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PSCF<span id="projectnumber">&#160;v1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">PSCF - Polymer Self-Consistent Field Theory</a></li><li class="navelem"><a class="el" href="developer_page.html">Developer Information</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">C++ Class Templates</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="developer_standards_page.html">Coding Standards</a> (Prev) &#160; &#160; &#160; &#160; <a class="el" href="developer_param_page.html">Parameter File I/O</a> (Next) <br  />
</p>
<p>The PSCF source code makes rather heavy use of C++ class templates to avoid duplication of code for closely analogous classes. For purposes of discussion, it is useful to divide class templates into two categories that are treated somewhat differently:</p>
<ul>
<li>Class templates in which the only template parameter is an integer dimension D of space, for which the only allowed values are D=1,2 or 3.</li>
<li>Generic class templates that contain template parameters other than the dimension of space.</li>
</ul>
<p>Class templates in which the only template parameter is the dimension of space are an important special case because they appears throughout the code for simulating systems periodic boundary conditions that is used in the pscf_pc and pscf_pg programs.</p>
<p>We discuss these two categories separately below because they are treated differently by the PSCF build system: For class templates for which the only template parameter is the spatial dimension D, the build system explicitly instantiates classes for the three physically relevant values of D=1, D=2 and D=3, and later links to these pre-compiled classes. For all other types of class template, the build system instead generally relies on implicit template instantiation.</p>
<h1><a class="anchor" id="developer_template_dimension_sec"></a>
Spatial Dimension as a Template Paramaeter</h1>
<p>In the source code for the pscf_pc and pscf_pg programs for periodic structures, many classes are defined by instantiating class templates in which the dimension of space (denoted by D) is the only template parameter. This pattern is used for most of the classes defined in the prdc/, rpc/ and rpg/ namespace level directories. In this usage, the only relevant values of D are D=1, D=2, and D=3, which are used for periodic structures in which fields are periodic in 1, 2 or 3 spatial dimensions. For example, a lamellar phase would be simulated using classes defined with D=1, while a hexagonal phase would be simulated using classes in which D=2. <br  />
</p>
<p>The PSCF build system is designed to explicitly instantiate classes with D=1, 2 and 3 for class templates in which D is the only template parameter. Source code for this type of class template is almost always divided among three files with the same base name but different file extensions, which is organized as follows:</p>
<ul>
<li>A header file with extension *.h contains the class definition and definitions of any functions that are declared "inline".</li>
<li>A template implementation file with extension *.tpp contains the definitions of all non-inline member functions. The *.tpp file use an "include" macro to includes the associated header file.</li>
<li>A source file with extension *.cpp for C++ code or *.cu for C++/CUDA code. This source code file includes the *.tpp file, and contains expressions that explicitly instantiates the template for the D=1, 2 and 3.</li>
</ul>
<p>The build system compiles the *.cpp or *.cu file for each such class template, and thereby instantiates classes with D=1, 2 and 3.</p>
<p>For example, the file <a class="el" href="Basis_8h_source.html">src/prdc/crystal/Basis.h</a> contains a definition of a class template for a class template Pscf::Prdc::Basis&lt;D&gt;, in which D is the dimension of space. This is defined (in skeleton form) as </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line"><span class="keyword">namespace </span>Prdc {</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> D&gt; </div>
<div class="line">   <span class="keyword">class </span>Basis {</div>
<div class="line">    ....</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
<div class="ttc" id="anamespacePscf_html"><div class="ttname"><a href="namespacePscf.html">Pscf</a></div><div class="ttdoc">PSCF package top-level namespace.</div><div class="ttdef"><b>Definition</b> <a href="param__pc_8dox_source.html#l00001">param_pc.dox:1</a></div></div>
</div><!-- fragment --><p> The file <a class="el" href="Basis_8tpp_source.html">src/prdc/crystal/Basis.tpp</a>, which is longer than the header file, contains the actual definitions of all non-inline member functions for the Basis class. The file <a class="el" href="Basis_8cpp_source.html">src/prdc/crystal/Basis.cpp</a> contains a several explicit instantiation statements, of the form </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Basis.tpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line"><span class="keyword">namespace </span>Prdc {</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;1&gt;;</div>
<div class="line">   <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;2&gt;;</div>
<div class="line">   <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;3&gt;;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p> The build system compiles <a class="el" href="Basis_8cpp_source.html">src/prdc/crystal/Basis.cpp</a> and then adds the resulting object code for these three class template instantations into a static library.</p>
<p>As an essential part of this system, the header file for each such class template also contains a block of "extern" declarations for instantiations of the template the template with D=1, D=2, and D=3. <br  />
 The relevant block for the <a class="el" href="classPscf_1_1Prdc_1_1Basis.html" title="Symmetry-adapted Fourier basis for pseudo-spectral scft.">Pscf::Prdc::Basis</a> template in file <a class="el" href="Basis_8h_source.html">src/prdc/crystal/Basis.h</a> looks like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef PSCF_BASIS_TPP</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;1&gt;;</div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;2&gt;;</div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;3&gt;;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> These "extern" declarations guarantee that files other than <a class="el" href="Basis_8tpp_source.html">Basis.tpp</a> that directly or indirectly include the header <a class="el" href="Basis_8h_source.html">Basis.h</a> will not attempt to implicitly instantiate the template as needed, but will instead assume that they are instantiated elsewhere. This pattern allows the required instantiations for D=1, 2 and 3 to be compiled once and then linked, as would normally be done for non-templated classes.</p>
<p>Note that an "ifndef" macro surrounds the block of extern declarations in the header file in the above example. This ifndef macro tests for definition of guard macro that is defined in the associated *.tpp file. This usage is designed to guarantee such that that this block of extern declarations will be skipped when the header file is included into the associated *.tpp file, which is then also included into the source file, but that this block will be retained when the header file is included into any other file. The extern declarations must be skipped when the header is included into the *.tpp file so that, when the *.tpp file is included into a *.cpp or *.cu source file, the "extern" declarations will not contradict the explicit instantiation statements given in the source file. An analogous "ifndef" macro must surround the extern declarations in every template header file that uses this pattern.</p>
<p>In order for this pattern to work correctly for class templates in which D is the only template parameter:</p>
<ul>
<li>The header file with extension *.h must contain a block of "extern" declarations that is surrounded by an ifndef macro that refers to a header guard macro defined in the *.tpp file (e.g., PRDC_BASIS_TPP), which omits this block when the header file is included into the associated *.tpp file.</li>
<li>The template implementation file with extension *.tpp must contain a header guard that defines an appropriate guard macro (e.g., PRDC_BASIS_TPP), and must include the header file after the definition of the guard macro.</li>
<li>A source file with file extension *.cpp or *.cu that will be compiled by the build system must include the *.tpp file and must contain statements to explicitly instantiate classes with D=1, 2 and 3</li>
<li>A <em>.tpp template implementation file that is included into a compiled source file may *never</em> be included into any file other than the associated source file.</li>
</ul>
<p>In this usage pattern, the *.tpp file is effectively treated as part of the source file, since it is included into the source file and should never be directly or indirectly included into any other file. Despite the division of code into three files, this usage is analogous to the usual organization of code for non-templated classes into a header that may be included into other classes and a source file that is compiled.</p>
<h1><a class="anchor" id="developer_template_generic_sec"></a>
Generic Class Templates</h1>
<p>In what follows, we refer to class templates that contain template parameter other than the spatial dimension D as "generic" templates. The PSCF build system generally relies on implicit rather than explicit instantiation for such generic templates. This requires an entirely different file organization than that described above for the special case in which D is the only template parameter. For such generic templates:</p>
<ul>
<li>There is no associated *.cpp or *.cu source file.</li>
<li>Inclusion of the header file must by another file must cause direct or indirect inclusion of definitions for all class template member functions.</li>
</ul>
<p>Source code for such a generic class template may be organized into either of two ways:</p>
<ul>
<li>Definitions of all class member functions may be placed in the header file.</li>
<li>Source code for a class template may be divided between a *.h header file and *.tpp template implementation file.</li>
</ul>
<p>In the first case, in which all of the code for class template is placed in a *.h header file, there is no associated *.tpp file. In the latter case, in which the source code for a class template is divided between a header and implementation file:</p>
<ul>
<li>Definitions of some or all of the class member functions may be placed in the *.tpp implementation file.</li>
<li>The *.tpp implementation file must be included into the *.h header file near the end of the header file.</li>
<li>The *.tpp file may not include the header file.</li>
<li>The *.tpp file may never be directly included by any file other than the associated header file.</li>
</ul>
<p>In this usage, the *.tpp implementation file acts in practice like a part of the header file, because it will be included indirectly by any file that includes the header file.</p>
<p>A template implementation file with file extension *.tpp should thus always be included either into an associated compilable source file (for templates with a single template parameter D that are explicitly instantiated) or into the associated header file (for generic templates that are implicitly instantiated). For either type of class template, a *.tpp implementation files should never be directly included into any file other than an associated source or header file.</p>
<p><br  />
 <a class="el" href="developer_standards_page.html">Coding Standards</a> (Prev) &#160; &#160; &#160; &#160; <a class="el" href="developer_page.html">Developer Information</a> (Up) &#160; &#160; &#160; &#160; <a class="el" href="developer_param_page.html">Parameter File I/O</a> (Next) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 14 2025 16:29:26 for PSCF by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
