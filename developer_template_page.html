<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSCF: C++ Class Templates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PSCF<span id="projectnumber">&#160;v1.3.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="index.html">PSCF - Polymer Self-Consistent Field</a></li><li class="navelem"><a href="developer_page.html">Developer Information</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">C++ Class Templates </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="developer_standards_page.html">Coding Standards</a> (Prev) &#160; &#160; &#160; &#160; <a class="el" href="developer_param_page.html">Parameter File I/O</a> (Next) <br  />
</p>
<p>The PSCF source code makes rather heavy use of C++ class templates to avoid duplication of code for closely analogous classes. To reduce compilation times, PSCF also relies heavily on explicit instantiation of templates in cases for which there are only a few possible valid values for the template parameters. This page briefly explains both some of the ways in which templates are used in PSCF, and conventions used to explicitly instantiate some class template specializations.</p>
<h1 class="doxsection"><a class="anchor" id="developer_template_uses_sec"></a>
Use cases for templates</h1>
<p>Reasons for the use of C++ templates in PSCF generally fall into one of the following three categories: </p><ol type="A">
<li>
<p class="startli"><b> Container templates </b> : Arrays and other containers are defined as specializations of class templates in which the type of each element is a template parameter. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b> Templatizing the dimension of space </b> : In code for periodic systems, the dimension of space is treated as a template parameter, denoted by D. </p>
<p class="endli"></p>
</li>
<li>
<b> Templates as base classes </b> : Specializations of some class templates are used as base classes for closely analogous derived classes used by different programs (pscf_1d, pscf_pc, and pscf_pg), to reduce code duplication.  </li>
</ol>
<p>Each of these uses is discussed in more detail below.</p>
<h2 class="doxsection"><a class="anchor" id="developer_template_uses_container_sub"></a>
A. Container templates</h2>
<p>The most conventional use of templates in PSCF is their use to define generic data containers. This is analogous to the use of templates in the C++ standard library to define container templatess such as std::vector. Rather than using the container templates defined in the standard library, however, PSCF relies primarily on a set of container templates that are distributed with the package. For example, the source code for PSCF contains many one-dimensional arrays, most of which are defined as specializatons of a class template named <a class="el" href="classUtil_1_1DArray.html" title="Dynamically allocatable contiguous array template.">Util::DArray</a> that takes the data type of a single element as a template parameter. The source code for DArray and other container templates used in PSCF is located in directory src/util/containers.</p>
<p>The DArray class template defines a simple dynamically allocated array that allows individual elements to be access via an overloaded subscript [] operator, using the same syntax for this as that used by built-in C-arrays. A DArray holds data in a contiguous block of memory that is dynamically allocated by invoking a member function named "allocate" at some point after construction, and the size of the array remains constant after allocation. Many of the DArray containers used by a PSCF program are allocated during processing of the parameter file, immediately after the information required to determine the required array size is read from the parameter file.</p>
<p>The decision to rely primarily on DArray and other home-grown containers throughout PSCF was based, in part, on a preference for this type of interface for memory management, in which allocation is separate from both construction or addition of elements. Note that this interface is different from that used by either a std::vector (which is a fully dynamic array whose size can grow at any time by pushing elements to the end of the array) or by std::array (for which the array size must be known at compile time). The home-grown container classes used by PSCF also provide a mechanism to enable run-time checking of array bounds in a debugging version of the code (which is enabled by defining a preprocessor macro), to facilitate debugging, but to turn off these additional checks in production code, to maximize performance.</p>
<h2 class="doxsection"><a class="anchor" id="developer_template_uses_D_sub"></a>
B. Templatizing the dimension of space</h2>
<p>Throughout the code for systems with periodic boundary conditions in namespaces <a class="el" href="namespacePscf_1_1Prdc.html" title="Periodic fields and crystallography.">Pscf::Prdc</a>, <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a>, and <a class="el" href="namespacePscf_1_1Rpg.html" title="SCFT and PS-FTS with real periodic fields (GPU)">Pscf::Rpg</a>, the dimension of space, denoted by D, is treated as a template parameter. Almost all of the classes used in these three namespaces are defined as specializations of class templates in which D is a template parameter, and is often the only template parameter. For example, classes used by pscf_pc to represent a block within a block polymer and an entire polymer are defined as specializations of templates that are declared within namespace <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a> as "template &lt;int D&gt; class Block" and "template &lt;int D&gt; class Polymer", respectively. For each class template for which D is the only template parameter, the PSCF build system actually explicitly instantiates (i.e., compiles code for) three specializations corresponding to the three possible values of D = 1, 2, and 3.</p>
<p>The ability to use different values for the spatial dimension D is primarily relevant to SCFT calculations of periodic structures. In this context, D is used to specify the number of directions or coordinates along which some structure of interest is periodic. For example, the SCFT solution of a lamellar phase is described by fields that are periodic with respect to one coordinate (the coordinate perpendicular to the layers), and independent of the remaining two orthogonal coordinates. As a result, SCFT calculation for a lamellar phase are normally performed by PSCF using specializations with D=1 for all class templates in which D appears as a template parameter. PS-FTS calculations are instead usually performed using D=3 even for simulations of a lamellar or columnar phases, because the fluctuations that are sampled in such stochastic simulations can depend on all three physical coordinates, even if the average field configuration exhibits a periodic dependence on only one or two coordinates.</p>
<p>The decision to treat D as a template parameter was made to simplify design and (slightly) improve performance of parts of the code that deal with crystallography. Treating D as a template parameter allows the innermost parts of algorithms that involve description of unit cells, reciprocal lattice vectors, symmetry operations, and space groups to be written using data structures that represent D-dimensional vectors and D \( \times \) D matrices using memory blocks whose sizes are known at compile time. This allows instances of the classes the represent such quanties to be constructed as local variable and used as array elements without needing to explicitly allocate dynamic memory for each small D-dimensional vector or D \( \times \) D matrix.</p>
<h2 class="doxsection"><a class="anchor" id="developer_template_uses_base_sub"></a>
C. Templates as base classes</h2>
<p>The C++ version of PSCF was designed as package that could contain code for several different implementations of polymer field theory, corresponding to different executable programs. Currently, PSCF contains code for three programs (pscf_1d, pscf_pc and pscf_pg, respectively) that are constructed from source code defined in three corresonding program-level namespaces (<a class="el" href="namespacePscf.html" title="PSCF package top-level namespace.">Pscf</a>:R1d, <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a>, and <a class="el" href="namespacePscf_1_1Rpg.html" title="SCFT and PS-FTS with real periodic fields (GPU)">Pscf::Rpg</a>, respectively). These three programs differ because they are either designed for different types of spatial domain or use different hardware (CPU vs. GPU). By convention, named entitites (classes, class templates, or functions) that are defined in any one any one program-level namespace are used in only one executable file, and may not use entities defined another program level namespace. Classes and other entitites that can be used in two or more executable must instead be defined in the <a class="el" href="namespacePscf.html" title="PSCF package top-level namespace.">Pscf</a> or <a class="el" href="namespacePscf_1_1Prdc.html" title="Periodic fields and crystallography.">Pscf::Prdc</a> namespace. Entities that are designed specifically for systems with periodic boundary condtions but that may be used in either pscf_pc or pscf_pg are generally defined in namespace <a class="el" href="namespacePscf_1_1Prdc.html" title="Periodic fields and crystallography.">Pscf::Prdc</a> and in directory src/prdc. Entities that may be used in any PSCF program are defined in the parent namespace <a class="el" href="namespacePscf.html" title="PSCF package top-level namespace.">Pscf</a> and in directory src/pscf.</p>
<p>Many of the basic data structures and algorithms used in the three different PSCF programs are closely analogous, but are implemented using different classes for analogous purposes. Closely analogous classes used in different executables are generally given the same class name but are defined in different program-level namespaces. For example, each of the three program-level namespaces uses a class or class template named Block that represents one block within a block polymer. The executable pscf_1d uses a class named Block that is defined in namespace <a class="el" href="namespacePscf_1_1R1d.html" title="SCFT with real 1D fields.">Pscf::R1d</a>, while pscf_pc uses a class template named Block that is defined namespaces <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a>, which takes D as a template parameter. The convention that prohibits code in one program-level namespace from using names defined in another allows names to be re-used in this way without causing name clashes.</p>
<p>Many of the differences between analogous classes used by different executables arise from the fact that different executables use different classes to represent functions of position, also known as fields. Throughout the code in namespace <a class="el" href="namespacePscf_1_1R1d.html" title="SCFT with real 1D fields.">Pscf::R1d</a> that is used to construct pscf_1d, fields are represented using a simple 1D DArray&lt;double&gt; container in which each element represents the value of a real field on a node of a regular 1D grid. Within code in namespace Rpc that is used to construct pscf_pc, real-valued fields for systems that are periodic in D dimensions are represented by a template specialization RField&lt;D&gt; of a class template RField that is defined in namespace <a class="el" href="namespacePscf_1_1Prdc_1_1Cpu.html" title="Fields and FFTs for periodic boundary conditions (CPU)">Pscf::Prdc::Cpu</a>, for which D is the only template parameter. Within code in namespace Rpg that is used to construct pscf_pg, each such real-valued field in D-dimensional space is instead represented by a specialization RField&lt;D&gt; of another class template named RField that is defined in namespace <a class="el" href="namespacePscf_1_1Prdc_1_1Cuda.html" title="Fields, FFTs, and utilities for periodic boundary conditions (CUDA)">Pscf::Prdc::Cuda</a>. The class templates <a class="el" href="classPscf_1_1Prdc_1_1Cuda_1_1RField.html" title="Field of real values on a regular mesh, allocated on a GPU device.">Pscf::Prdc::Cuda::RField</a> and <a class="el" href="classPscf_1_1Prdc_1_1Cpu_1_1RField.html" title="Field of real double precision values on an FFT mesh.">Pscf::Prdc::Cpu::RField</a> are closely analogous <b>except</b> for the fact that the block of contiguous memory that actually contains the field data stored by a class <a class="el" href="classPscf_1_1Prdc_1_1Cuda_1_1RField.html" title="Field of real values on a regular mesh, allocated on a GPU device.">Pscf::Prdc::Cuda::RField</a>&lt;D&gt; is allocated in global GPU memory, while the memory used by Pscf::Cpu::RField&lt;D&gt; is allocated in CPU memory. As one consequence of this difference, individual elements of an <a class="el" href="classPscf_1_1Prdc_1_1Cuda_1_1RField.html" title="Field of real values on a regular mesh, allocated on a GPU device.">Pscf::Prdc::Cuda::RField</a>&lt;D&gt; container are not directly accessible from the CPU via the subscript operator. This difference necessarily causes other differences in code that use these two classes. Because many other classes used by each program directly or indirectly own multiple instances of the class that represents a field, the use of different data types to represent fields ended up infecting the definitions of many other classes, forcing a design in which different programs are based on distinct but analogous sets of class definitions.</p>
<p>The source code for analogous classes used by different executable programs is often itself closely analogous, except for their use of distinct data types for analogous purposes. These analogies are particularly strong between the code defined in <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a> and Pscf::Ppg, because the corresponding pscf_pc and pscf_pg programs are designed to solve the same problem using different hardware, and to provide identical features to the user. To avoid unnecessary code duplication, analogous classes defined in these two program-level namespaces are sometimes derived from different specializations of a single class template that is defined in <a class="el" href="namespacePscf.html" title="PSCF package top-level namespace.">Pscf</a> or <a class="el" href="namespacePscf_1_1Prdc.html" title="Periodic fields and crystallography.">Pscf::Prdc</a>, in which the base class template contains template code for data structures and algorithms that appear in both implementations.</p>
<p>Class templates that are designed to be used as base classes appear in the following locations:</p>
<ul>
<li>The directory src/pscf/solvers contains a set of class templates named PropagatorTmpl, BlockTmpl, PolymerTmpl, and MixtureTmpl that are used as base classes for classes that are used to solve the ideal gas problems in every PSCF program.</li>
<li>The directories src/prdc/field, src/prdc/solvers, and src/prdc/system contain templates for a variety of class templates that are each designed to be used as base classes for a pair of closely analogous classes used in pscf_pc and pscf_pg, respectively, to treat problems with periodic boundary conditions.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="developer_template_types_sec"></a>
Implicit vs. Explicit Instantiation</h1>
<p>For some purposes, it is useful to divide class templates used by PSCF into two categories that differ in how they are treated by the build system: </p><ol type="A">
<li>
<p class="startli"><b> Implicitly instantiated (standard) templates </b> : These are C++ class templates that are designed to be implicitly instantiated as needed during compilation of source code for other entities that use a particular specialization. Because this is the default behavior of C++ templates, as described in most textbook discussions, we also refer to these as standard templates. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b> Explicitly instantiated templates </b>: These are templates for which there exist only a few possible valid specializations, and for which all valid specializations are compiled by explicit instantiation. </p>
<p class="endli"></p>
</li>
</ol>
<p>Conventions used in PSCF in the source code for these two types of class templates are discussed separately below.</p>
<h2 class="doxsection"><a class="anchor" id="developer_template_types_generic_sub"></a>
A. Implicitly instantiated (standard) templates</h2>
<p>Standard class templates are designed to rely on the use of implicit instantiation of class template specializations whenever they are used in the code for other classes and functions. Standard class templates used by PSCF include:</p>
<ul>
<li>Container class templates that are defined in the src/util/containers directory, such as DArray and FSArray.</li>
<li>The <a class="el" href="classPscf_1_1PropagatorTmpl.html" title="Template for propagator classes.">Pscf::PropagatorTmpl</a> class template defined in the src/pscf/solvers directory.</li>
</ul>
<p>The class definition for each standard class template is contained in a header file that ends with file suffix .h. The base name of this header file is generally the same as the name of the class template. This header file should also always include definitions of any inline member functions. Definitions of non-inline member functions for a standard class templates may be organized in either of two ways:</p>
<ul>
<li>Definition of all class member functions may also be placed in the header file, with file name suffix .h.</li>
<li>Definitions of non-inline class member functions may be placed in a separate template implementation file, with file name suffix .tpp.</li>
</ul>
<p>In the first case, a single header file contains all of the source code for a particular class template. In the latter case, the source code for the class template is divided between a *.h file and *.tpp file. In this latter case:</p>
<ul>
<li>The *.tpp implementation file is included into the *.h header file at the bottom of the header file.</li>
<li>The *.tpp file should never be directly included by any file other than the associated header file.</li>
</ul>
<p>In this usage, the *.tpp implementation file is treated by the compiler as a part of the header file, because the implementation file is included into the header file by the preprocessor, and thus will be indirectly indirectly included by any file that includes the header file. In this case, the division of the source code into two files is simply a convenience for human readers. For either way of organizing code for a standard template, the compiler sees a translation unit that contains the class definition and all member function definitions.</p>
<h2 class="doxsection"><a class="anchor" id="developer_template_explicit_sub"></a>
B. Explicitly instantiated templates</h2>
<p>The source code for PSCF contains some types of class templates for which there exist only a few valid values for the template parameters, and thus only a few possible valid specializations. For some such classes, the PSCF build system relies heavily on the use of explicit instantiation to compile all valid specializations. Use of explicit instantiation allows the build system to treat these template specializations in a manner very similar to that used for non-templated classes, in which valid specializations are compiled to form object code modules that are placed in an object file, incorporated into a library file, and later linked to create executables. The conventions used by PSCF for such classes require the use of "extern template" explicit instantiation declarations in header files to suppress unwanted implicit instantiation of these templates, as well as explicit instantiation definitions in source files that are compiled by the build system.</p>
<p>The use of explicit instantiation for many classes reduces some potential disadvantages of the heavy use of templates by PSCF. Use of explicit instantiation signficantly reduces compilation times, because it reduces the amount of source code that must be included into other files that include the header for a such a class template. It also tends to simplify debugging of errors during development, because it tends to break the compilation process into smaller steps, and often allows the compiler to generate more easily interpretable error messages in response to syntax errors encountered during compilation.</p>
<p>The classes that the PSCF build system compiles by explicit instantiation generally fall into one of two categories: </p><ol type="1">
<li>
<p class="startli">Class templates for which the dimension D of space is the the only template parameter. </p>
<p class="endli"></p>
</li>
<li>
Class templates that are used only as base classes for a few closely analogous classes used by different programs.  </li>
</ol>
<p>The way that source code is organized into files is slightly different for the two use cases listed above, which are thus described separately below:</p>
<p><b> B.1: Class templates for which D is the only template parameter</b> :</p>
<p>Class templates for which the dimension of space D is the only template parameter appear throughout the source code for periodic system that is located in subdirectories src/prdc, src/rpc, and src/prg. The source code for each such class template is usually divided among three files with the same base name but different file name suffixs:</p>
<ul>
<li>A header file with suffix .h contains the class definition and definitions of any functions that are declared "inline".</li>
<li>A template implementation file with suffix .tpp contains the definitions of all non-inline member functions. The *.tpp file use an "include" macro to include the associated header file.</li>
<li>A compilable source file with suffix *.cpp for standard C++ code or *.cu for CUDA C++ code. This source code file includes the *.tpp file, and contains explicitly instantiation definitions of the template for the three allowed values of D=1, 2, and 3.</li>
</ul>
<p>In this usage, the header file must also contain "extern template" declarations that suppress implicit instantiation of the template for the three allowed values of D.</p>
<p><em> Example: </em> As an example, consider the source code files associated with the class template <a class="el" href="classPscf_1_1Prdc_1_1Basis.html" title="Symmetry-adapted Fourier basis for pseudo-spectral SCFT.">Pscf::Prdc::Basis</a>, for which the only template paramer is the dimension of space, D.</p>
<p>The header file <a class="el" href="Basis_8h_source.html">src/prdc/crystal/Basis.h</a> contains a definition of class template <a class="el" href="classPscf_1_1Prdc_1_1Basis.html" title="Symmetry-adapted Fourier basis for pseudo-spectral SCFT.">Pscf::Prdc::Basis</a>, but that does not contain definitions of non-inline member functions. The key contents of this file, in skeleton form, look like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef PRDC_BASIS_H</span></div>
<div class="line"><span class="preprocessor">#define PRDC_BASIS_H</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line"><span class="keyword">namespace </span>Prdc {</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Class definition</span></div>
<div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> D&gt;</div>
<div class="line">   <span class="keyword">class </span>Basis {</div>
<div class="line">      ...</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Inline member function definitions</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// External instantiation declarations</span></div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;1&gt;;</div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;2&gt;;</div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;3&gt;;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="anamespacePscf_html"><div class="ttname"><a href="namespacePscf.html">Pscf</a></div><div class="ttdoc">PSCF package top-level namespace.</div><div class="ttdef"><b>Definition</b> <a href="param__domain_8dox_source.html#l00001">param_domain.dox:1</a></div></div>
</div><!-- fragment --><p> The template implementation file <a class="el" href="Basis_8tpp_source.html">src/prdc/crystal/Basis.tpp</a> contains the definitions of all non-inline member functions for the Basis class template, includes the header file. A skeleton of the essential elements of this file (which is actually much longer than the header file) looks something like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Basis.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line"><span class="keyword">namespace </span>Prdc {</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Non-inline member function definitions</span></div>
<div class="line">   ....</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p> The compilable source file <a class="el" href="Basis_8cpp_source.html">src/prdc/crystal/Basis.cpp</a> contains a several explicit instantiation definitions for specializations with different values of the integer D, and includes includes the template implementation file: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Basis.tpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line"><span class="keyword">namespace </span>Prdc {</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;1&gt;;</div>
<div class="line">   <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;2&gt;;</div>
<div class="line">   <span class="keyword">template</span> <span class="keyword">class </span>Basis&lt;3&gt;;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p> The PSCF build system compiles the file <a class="el" href="Basis_8cpp_source.html">src/prdc/crystal/Basis.cpp</a>, places the resulting object code for the three specializations in a file named Basis.o, and later incorporates the object code in this file into a static library file named prdclib.a.</p>
<p>For explicit instantiation to work correctly, implicit instantiation must be suppressed by "extern template" explicit instantiation declarations for all class specializations that are compiled by explciit specialization. In the use case described here, implicit instantiation is suppressed for specializations with D=1, 2, and 3 by "extern template" declarations that are placed near the bottom of the class template header file, as shown in the above example for the <a class="el" href="Basis_8h_source.html">Basis.h</a> file. An "extern template" declaration for a particular class template specialization instructs the compiler to not perform implicit instantiation for that specialization, and to assume that the specialization will be compiled by explicit instantiation definitions that may appear in a different translation unit, but that the resulting object code will be made accessible during during the linking stage.</p>
<p>In this usage case, in contrast to the case of a standard implicitly instantiated class template, the *.h header file does not include the .tpp implementation file, while the *.tpp file instead includes the .h. As a result, inclusion of the header file by another file will not result in indirect inclusion of the definitions for non-inline member functions. This reduces compile times, by avoiding inclusion of these function definitions into multiple other files.</p>
<p>To summarize the use of "extern template" declarations for this use case:</p>
<ul>
<li>The *.h header file must contain "extern template" explicit instantiation declarations for D=1,2, and 3, and does not include the *.tpp template implementation file. This header file contains the class template definition and definitions of in-line member functions.</li>
<li>The template implementation file with suffix .tpp contains definitions of non-inline functions, and must include the header file.</li>
<li>A compilable source file with file suffix .cpp or .cu must contain explicit instantiate definitions for class template specialization with D=1, 2 and 3, and must include the *.tpp file</li>
<li>The *.tpp template implementation file for such a class template may never be included into any file other than the associated compilable source file, and the compilable source file may never be included into any other file.</li>
</ul>
<p>In this usage pattern, the *.tpp file is treated by compiler as if it were part of the compilable *.cpp or *.cu source file, since it is included into the source file and is never directly or indirectly included into any other file. Despite the use of three files, this usage is thus analogous to the usual organization of code for non-templated classes into a header file containing the class definition and inline functions and a compilable source file contains definitions of all non-inline member functions.</p>
<p><b> B.2. Class templates that are only used as base classes </b>:</p>
<p>Some class templates that are are defined to be used only as base classes for a small number of derived class templates are compiled by explicit instantiation. Specifically, there are several class templates that are defined in namespace <a class="el" href="namespacePscf_1_1Prdc.html" title="Periodic fields and crystallography.">Pscf::Prdc</a> are designed to be used only as base classes for two closely analogous derived class templates that are defined in <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a> and <a class="el" href="namespacePscf_1_1Rpg.html" title="SCFT and PS-FTS with real periodic fields (GPU)">Pscf::Rpg</a> for use in pscf_pc and pscf_pg, respectively. Most of the class templates defined in subdirectories src/prdc/field, src/prdc/solvers and src/prdc/system were designed as this sort of base class, to duplication of code by analogous classes in <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a> and <a class="el" href="namespacePscf_1_1Rpg.html" title="SCFT and PS-FTS with real periodic fields (GPU)">Pscf::Rpg</a>. Each such base class template in namespace Prdc has the dimension of space D as an integer template parameter, but also has one or more class template parameters that must be assigned different class names for use in the derived classes defined in Rpc and Rpg. Each of the resulting derived class templates defined in Rpg or Rpc is a template for which D is the only template parameter.</p>
<p>As an example, we consider the base class template <a class="el" href="classPscf_1_1Prdc_1_1FieldIoTmpl.html" title="File input/output, format conversions and other utilities for fields.">Pscf::Prdc::FieldIoTmpl</a> . Partial specializations of this template are used as base classes for two derived class templates named FieldIo that are defined in the program-level namespaces <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a> and <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a>. Each of these two FieldIo derived class templates has the integer D as its only template parameter. Within each of the two program-level namespaces, <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a> and <a class="el" href="namespacePscf_1_1Rpg.html" title="SCFT and PS-FTS with real periodic fields (GPU)">Pscf::Rpg</a>, specializations of FieldIo&lt;D&gt; with D=1, 2, or 3 provides tools for file input and output and conversion among different field representations for periodic fields that can be represented numerically by a set of values on the nodes of a D-dimensional regular grid.</p>
<p><em> Base class template </em></p>
<p>The <a class="el" href="classPscf_1_1Prdc_1_1FieldIoTmpl.html" title="File input/output, format conversions and other utilities for fields.">Pscf::Prdc::FieldIoTmpl</a> base class template takes D as an integer template parameter, and also takes 3 class name parameters that are denoted by RFT, KFT, and FFT within the template definition. The essential elements of the definition of Prdc::Prdc::FieldIoTmpl in the header file <a class="el" href="FieldIoTmpl_8h_source.html">src/prdc/field/FieldIoTmpl.h</a> thus look something like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef PRDC_FIELD_IO_TMPL_H</span></div>
<div class="line"><span class="preprocessor">#define PRDC_FIELD_IO_TMPL_H</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line"><span class="keyword">namespace </span>Prdc {</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> D, <span class="keyword">class</span> RFT, <span class="keyword">class</span> KFT, <span class="keyword">class</span> FFT&gt;</div>
<div class="line">   <span class="keyword">class </span>FieldIoTmpl</div>
<div class="line">   {</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Member declarations</span></div>
<div class="line"> </div>
<div class="line">   };</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Inline member function definitions</span></div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Within this template, the parameters RFT, KFT, and FFT are aliases for classes that represent, respectively:</p>
<ul>
<li>RFT: a real-value field defined on a regular D-dimensional mesh</li>
<li>KFT: the discrete Fourier transform of such a real-valued field</li>
<li>FFT: a class that can perform Fast Fourier transform (FFT) operations</li>
</ul>
<p>These three class names are treated as template parameters because different classes are used for these purposes by pscf_pc and pscf_pg, which differ in whether or not they use a GPU. The field and FFT class templates used by pscf_pc, which use standard CPU hardware, are defined in namespace <a class="el" href="namespacePscf_1_1Prdc_1_1Cpu.html" title="Fields and FFTs for periodic boundary conditions (CPU)">Pscf::Prdc::Cpu</a> within files located in directory src/prdc/cpu. Corresponding class templates used by pscf_pg, which use a GPU, are defined in namespace <a class="el" href="namespacePscf_1_1Prdc_1_1Cuda.html" title="Fields, FFTs, and utilities for periodic boundary conditions (CUDA)">Pscf::Prdc::Cuda</a> within files located in directory src/prdc/cuda.</p>
<p>Note that the header for the base class template does not contain any "extern template" explicit instantiation declarations. The required declarations are instead placed in the header file for each derived class template.</p>
<p><em> Derived class template </em></p>
<p>As an example of one of the two corresponding derived class templates, we consider the template <a class="el" href="classPscf_1_1Rpc_1_1FieldIo.html" title="File input/output operations and format conversions for fields.">Pscf::Rpc::FieldIo</a>. This is a class template that is used by the pscf_pc program, for which the integer D is the only template parameter. For each valid value of D=1, 2 or 3, a class template specialization <a class="el" href="classPscf_1_1Rpc_1_1FieldIo.html" title="File input/output operations and format conversions for fields.">Pscf::Rpc::FieldIo</a>&lt;D&gt; is derived from a specialization of the base class template <a class="el" href="classPscf_1_1Prdc_1_1FieldIoTmpl.html" title="File input/output, format conversions and other utilities for fields.">Pscf::Prdc::FieldIoTmpl</a> in which the three class name parameters are associated with the following fully qualified class names: </p><div class="fragment"><div class="line">RFT = <a class="code hl_class" href="classPscf_1_1Prdc_1_1Cpu_1_1RField.html">Pscf::Prdc::Cpu::RField&lt;D&gt;</a></div>
<div class="line">KFT = <a class="code hl_class" href="classPscf_1_1Prdc_1_1Cpu_1_1RFieldDft.html">Pscf::Prdc::Cpu::RFieldDft&lt;D&gt;</a></div>
<div class="line">FFT = <a class="code hl_class" href="classPscf_1_1Prdc_1_1Cpu_1_1FFT.html">Pscf::Prdc::Cpu::FFT&lt;D&gt;</a></div>
<div class="ttc" id="aclassPscf_1_1Prdc_1_1Cpu_1_1FFT_html"><div class="ttname"><a href="classPscf_1_1Prdc_1_1Cpu_1_1FFT.html">Pscf::Prdc::Cpu::FFT</a></div><div class="ttdoc">Fourier transform wrapper.</div><div class="ttdef"><b>Definition</b> <a href="cpu_2FFT_8h_source.html#l00037">cpu/FFT.h:38</a></div></div>
<div class="ttc" id="aclassPscf_1_1Prdc_1_1Cpu_1_1RFieldDft_html"><div class="ttname"><a href="classPscf_1_1Prdc_1_1Cpu_1_1RFieldDft.html">Pscf::Prdc::Cpu::RFieldDft</a></div><div class="ttdoc">Fourier transform of a real field on an FFT mesh.</div><div class="ttdef"><b>Definition</b> <a href="cpu_2RFieldDft_8h_source.html#l00031">cpu/RFieldDft.h:32</a></div></div>
<div class="ttc" id="aclassPscf_1_1Prdc_1_1Cpu_1_1RField_html"><div class="ttname"><a href="classPscf_1_1Prdc_1_1Cpu_1_1RField.html">Pscf::Prdc::Cpu::RField</a></div><div class="ttdoc">Field of real double precision values on an FFT mesh.</div><div class="ttdef"><b>Definition</b> <a href="cpu_2RField_8h_source.html#l00028">cpu/RField.h:29</a></div></div>
</div><!-- fragment --><p> These template arguments are field and FFT classes that are defined in namespace <a class="el" href="namespacePscf_1_1Prdc_1_1Cpu.html" title="Fields and FFTs for periodic boundary conditions (CPU)">Pscf::Prdc::Cpu</a>, which are all designed to use standard CPU hardware. The key elements of the header file for the resulting derived class template <a class="el" href="classPscf_1_1Rpc_1_1FieldIo.html" title="File input/output operations and format conversions for fields.">Pscf::Rpc::FieldIo</a> look like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef RPC_FIELD_IO_H</span></div>
<div class="line"><span class="preprocessor">#define RPC_FIELD_IO_H</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line"><span class="keyword">namespace </span>Rpc {</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">using namespace </span>Prdc;</div>
<div class="line">   <span class="keyword">using namespace </span>Prdc::Cpu</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Derived class template definition</span></div>
<div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> D&gt;</div>
<div class="line">   <span class="keyword">class </span>FieldIo : <span class="keyword">public</span> FieldIoTmpl&lt;D, RField&lt;D&gt;, RFieldDft&lt;D&gt;, FFT&lt;D&gt; &gt;</div>
<div class="line">   {</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Class member declarations</span></div>
<div class="line"> </div>
<div class="line">   };</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Explicit instantiation declarations</span></div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>FieldIo&lt;1&gt;;</div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>FieldIo&lt;2&gt;;</div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>FieldIo&lt;3&gt;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Prdc {</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">using namespace </span>Cpu</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Explicit instantiation declarations for base class</span></div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>FieldIoTmpl&lt;1, RField&lt;1&gt;, RFieldDft&lt;1&gt;, FFT&lt;1&gt; &gt;;</div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>FieldIoTmpl&lt;2, RField&lt;2&gt;, RFieldDft&lt;2&gt;, FFT&lt;2&gt; &gt;;</div>
<div class="line">   <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>FieldIoTmpl&lt;3, RField&lt;3&gt;, RFieldDft&lt;3&gt;, FFT&lt;3&gt; &gt;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Note the inclusion of several "using namespace" declarations in this file, which allow names from the Prdc and Prdc::Cpu namespaces to be used without including these namespace names as qualifiers.</p>
<p>The header file for the class template <a class="el" href="classPscf_1_1Rpg_1_1FieldIo.html" title="File input/output operations and format conversions for fields.">Pscf::Rpg::FieldIo</a> that is used by the pscf_pg program is very similar, except that it uses analogous field and FFT classes that are defined in namespace <a class="el" href="namespacePscf_1_1Prdc_1_1Cuda.html" title="Fields, FFTs, and utilities for periodic boundary conditions (CUDA)">Pscf::Prdc::Cuda</a>, which are all designed to use a GPU.</p>
<p>As shown in the above example, the header file for each derived class template (e.g., <a class="el" href="classPscf_1_1Rpc_1_1FieldIo.html" title="File input/output operations and format conversions for fields.">Pscf::Rpc::FieldIo</a>) includes "extern template" explicit instantiation declarations that suppress implicit instantiation not only of the three valid specializations of the derived class template (e.g., of Rpc::FieldIo&lt;D&gt; with D=1,2, and 3), but also of the three corresponding specializations of the base class template (e.g., of Prdc::FieldIoTmpl) that are used as base classes for these three derived class template specializations.</p>
<p>The "extern template" declarations for the three relevant base class template specializations is necessary because code that uses a valid specialization of a derived class template (e.g., <a class="el" href="classPscf_1_1Rpc_1_1FieldIo.html" title="File input/output operations and format conversions for fields.">Pscf::Rpc::FieldIo</a>&lt;D&gt;, with D=1, 2, or 3) may use a non-inlined member function that is defined by the base class template (e.g., a member of <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a>:::FieldIoTmpl&lt;D&gt;) and inherited by the derived class. In this situation, a C++ compiler would normally try to implicitly instantiate the required specialization of the base class member function, unless this behavior is suppressed by an "extern template" declaration. Any attempt to implicitly instantiation such a member function would fail, however, because the template implementation file for the base class template that contains definitions of all non-inline member functions is not included by the header file for the base class template, and thus is not accessible within the translation unit seen by the compiler. This usage thus requires that these three specializations of the base class template must be explicitly instantiated in a compilable source file that can be linked to create an executable for pscf_pc.</p>
<p>If a derived class template such as Rpc::FieldIo defines or redefines any non-inline member functions, these definitions may be placed in a template implementation file with file name suffix .tpp . This file, if it exists, must include both the header for the derived class template and the *.tpp implementation file for the base class template, because will need access to a complete definition of the base class template.</p>
<p>For example, the key elements of the template implementation file for <a class="el" href="classPscf_1_1Rpc_1_1FieldIo.html" title="File input/output operations and format conversions for fields.">Pscf::Rpc::FieldIo</a> looks something like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;FieldIo.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;src/prdc/field/FieldIoTmpl.tpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line"><span class="keyword">namespace </span>Rpc {</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Member function template definitions</span></div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p> Such a template implementation file may not exist for some such derived class templates if the derived class does not define or redefine any functions, but instead inherits all of its functionality from the base class template.</p>
<p>Explicit instantiation definitions for each valid specialization of the derived class template are placed in a separate compilable source file with file name suffix .cpp or .cu. This file must contain explicitly instantiation definitions not only the three instances of the derived class, but also the three specializations of the base class template from which the derived class specializations are derived. The translation unit formed from this source file must contain complete class template definitions for both the derived class template and the base class template in order to compile specializations of both. If a template implementation *.tpp file for the derived class template exists, the compilable source file only needs to include this file, which already includes all other relevant header and template implementation files. Otherwise, if there is no template implementation file for the derived class template, then the compilable source file must include both the header file for the derived class (e.g., <a class="el" href="rpc_2field_2FieldIo_8h_source.html">src/rpc/field/FieldIo.h</a>&gt;) and the template implementation file for the base class (e.g., <a class="el" href="FieldIoTmpl_8h_source.html">prdc/field/FieldIoTmpl.h</a>).</p>
<p>The essential elements of the compilable source file for the class template Rpc::FieldIo thus look like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;FieldIo.tpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacePscf.html">Pscf</a> {</div>
<div class="line">   <span class="keyword">namespace </span>Prdc {</div>
<div class="line">      <span class="keyword">using namespace </span>Cpu;</div>
<div class="line">      <span class="keyword">template</span> <span class="keyword">class </span>FieldIoTmpl&lt;1, RField&lt;1&gt;, RFieldDft&lt;1&gt;, FFT&lt;1&gt; &gt;;</div>
<div class="line">      <span class="keyword">template</span> <span class="keyword">class </span>FieldIoTmpl&lt;2, RField&lt;2&gt;, RFieldDft&lt;2&gt;, FFT&lt;2&gt; &gt;;</div>
<div class="line">      <span class="keyword">template</span> <span class="keyword">class </span>FieldIoTmpl&lt;3, RField&lt;3&gt;, RFieldDft&lt;3&gt;, FFT&lt;3&gt; &gt;;</div>
<div class="line">   }</div>
<div class="line">   <span class="keyword">namespace </span>Rpc {</div>
<div class="line">      <span class="keyword">template</span> <span class="keyword">class </span>FieldIo&lt;1&gt;;</div>
<div class="line">      <span class="keyword">template</span> <span class="keyword">class </span>FieldIo&lt;2&gt;;</div>
<div class="line">      <span class="keyword">template</span> <span class="keyword">class </span>FieldIo&lt;3&gt;;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p><em> Summary of file organization </em>:</p>
<p>The usage pattern described above is specific to base class templates that are designed to be used only as base classes for a few derived classes, and that designed to be are compiled by explicit instantiation.</p>
<p>The source code for each such base class template (such as <a class="el" href="classPscf_1_1Prdc_1_1FieldIoTmpl.html" title="File input/output, format conversions and other utilities for fields.">Pscf::Prdc::FieldIoTmpl</a>) is normally divided into two files:</p>
<ul>
<li>A header file with file name suffix .h that contains the class template definition and definitions of any inline member functions. This file does <b>not</b> include the class implementation file and does not contain any "extern template" declarations.</li>
<li>A template implementation file with file name suffix .tpp that contains definitions of any non-inline member functions, and that includes the header file.</li>
</ul>
<p>The source code for each of the two associated derived class templates (such as the two FieldIo class templates defined in namespaces <a class="el" href="namespacePscf_1_1Rpc.html" title="Real periodic fields, SCFT and PS-FTS (CPU).">Pscf::Rpc</a> and <a class="el" href="namespacePscf_1_1Rpg.html" title="SCFT and PS-FTS with real periodic fields (GPU)">Pscf::Rpg</a>) may be organized into either two or three files:</p>
<ul>
<li>A header file with file name suffix .h that contains the derived class template definition, and includes the header for the base class template. This file also contains a set of "extern template" explicit instantiation declarations for both the three valid specializations of the derived class template (e.g., <a class="el" href="classPscf_1_1Rpc_1_1FieldIo.html" title="File input/output operations and format conversions for fields.">Pscf::Rpc::FieldIo</a>&lt;D&gt; with D=1, 2, and 3) and of the three specializations of the base class template (e.g., of FieldIoTmpl) from which these specializations of the derived class template are derived.</li>
<li>An optional template implementation file with file name suffix .tpp that contains definitions of any non-inline member functions that are defined or re-defined by the derived class template. This file may be omitted if there are no such functions. If this file exists, it must include the *.tpp implementation file for the base class template as well as the *.h header file for the derived class template.</li>
<li>A compilable source file with file name suffix .cpp or .cu that contains explicit instantiation definitions for specializations of the derived class template with D=1, 2, and 3 and for the 3 corresponding explicit specializations of the base class template. This file must includes either the *.tpp implementation file for the derived class template, if one exists, or, otherwise, must include both the *.h header for the derived class template and the *.tpp template implementation file for the base class template.</li>
</ul>
<p><em> Restriction on usage of base class templates </em>:</p>
<p>The usage pattern that is described above, in which all "extern template" declarations are placed in the header file for the derived class templates, relies on a convention that requires that:</p>
<ul>
<li>Instances of specializations of this type of base class template (e.g., Pscf::Prdc::FieldIo) are <b>only</b> used as base classes for specializations of a few derived class templates, and are never constructed or used directly in any other context.</li>
<li>The header file for this type of base class template (e.g., <a class="el" href="FieldIoTmpl_8h_source.html">src/prdc/field/FieldIoTmpl.h</a>) may <b>never</b> be directly included into any file other than the header files for the few class templates that are directly derived from it (e.g., into the files <a class="el" href="rpc_2field_2FieldIo_8h_source.html">src/rpc/field/FieldIo.h</a> and <a class="el" href="rpg_2field_2FieldIo_8h_source.html">src/rpg/field/FieldIo.h</a>).</li>
</ul>
<p>These restrictions are necessary because the header file for the base class template does not include the corresponding template implementation file, and thus does not contain a complete class template definition, and also does not contain any "extern template" declarations to suppress implicit instantiation. As a result, direct inclusion of this file by ar file that creates an instance of a specialization of this base class template in some other context could cause the compiler to attempt to implicitly instantiate that specialization using an incomplete class template definition, leading to a compilation error.</p>
<p>Other files in the src/rpc or src/rpg directories may, however, safely include the header file for the derived class template that is defined in the same program-level directory (e.g., the file <a class="el" href="rpc_2field_2FieldIo_8h_source.html">src/rpc/field/FieldIo.h</a> or <a class="el" href="rpg_2field_2FieldIo_8h_source.html">src/rpg/field/FieldIo.h</a>). This usage is safe because these header files contain all of the required "extern template" declarations.</p>
<p><br  />
 <a class="el" href="developer_standards_page.html">Coding Standards</a> (Prev) &#160; &#160; &#160; &#160; <a class="el" href="developer_page.html">Developer Information</a> (Up) &#160; &#160; &#160; &#160; <a class="el" href="developer_param_page.html">Parameter File I/O</a> (Next) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for PSCF by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
